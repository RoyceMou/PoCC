#
# Vanderbilt University, Computer Science
# CS4287-5287: Principles of Cloud Computing
# Author: Aniruddha Gokhale
# Created: Nov 2016
# 

Purpose: The code here is used to demonstrate the homegrown wordcount
MapReduce framework on a network topology created using Mininet SDN
emulator The mininet part is based on examples from the mininet
distribution. The MapReduce  part has been modified from the earlier
thread-based implementation to a more process-based implementation
required for this sample code

New in this sample code:
---------------------------------
(1)
We move away from a thread-based map-reduce to realistic process-based
map-reduce where the map and reduce tasks are handled in separate
processes running on different machines.

(2)
We create data center-like topologies where we can have a single rack
where all machines are connected to a single switch, or two racks
where the master and reduce nodes are on rack, while map nodes are on
a second rack, or where all categories of nodes are on their own
racks. Each rack has its switch.

(3)
We use ZeroMQ's PUSH-PULL pattern to send tasks from master to
workers, and have the workers send their results to the "sink" which
is the master.  This is a gentle introduction to using ZeroMQ, which
is a messaging capability that makes writing socket-based code simpler
and elegant while eliminating a large number of accidental
complexities. It also supports many communication patterns. We use one
that is needed for us because we need a "barrier synchronization step"
after the map and reduce steps. This is achieved using the push-pull
and source-worker-sink pattern.

Since this is a load-balancing pattern, we had to use 4 different
ports on which various activities take place. Minimally, we are
required to specify the base port for the Master and then all the four
ports are derived from this.

Master to Map comm: via base port
Master to Reduce comm: base_port + 1
Map to MapSink barrier comm: base_port + 2
Reduce to ReduceSink barrier comm: base_port + 3

(4)
We also demonstrate a newer and more elegant way of command line
parsing in Python using the "argparse" package. This makes both
optional and positional command line parsing extremely simple and very
elegant as shown in the sample code.

(5)
We show how a mininet emulator that emulates a given topology can be
used to kickstart the map-reduce job on the emulated hosts.

(6)
We use the Pickle Python package to demonstrate save/load of in-memory
data structures like lists of lists into a file. This makes it very
simple to do the reduce activity

Steps needed for Assignment #4
--------------------------------------------
The general framework provided in this sample can be reused including
all of the mininet and topology creation as well as the overall
map-reduce framework including the ZeroMQ-based communication pattern
between master- and map-reduce workers.

What you will need to change is the logic for wordcount and replace it
with the logic for the DEBS 2014 Energy problem we are solving.

Directory contents
----------------------------
Files in this directory are as follows

mr_mininet.py:          main master file that starts the mininet
                                            topology and invokes the wordcount
                                            on the master node of the
                                            topology
mr_topology.py:        Topology class used to create the network
                                            topology in mininet. Used
                                            by mr_mininet.py
                                            
mr_wordcount.py:    main file to invoke the map reduce wordcount
                                            framework.

mr_framework.py:    Implements the entire logic for the wordcount map
                                            reduce

mr_thread.py:              A thread class used by the MR framework to
                                             start the barrier threads we need that behave
                                             as the map and reduce barrier sinks

mr_mapworker.py:    Logic for map task. Runs as a separate program.

mr_reduceworker.py:    Logic for reduce task. Runs as a separate program.

big.txt:                                Our data file

commands.txt:                Sample generated file

mr_barriersink.py:        Unused file. It implements the barrier as a
                                                process instead of thread. But this
                                                complicates things.


Running the code
--------------------------
bash prompt>  sudo mr_mininet -p 5557 -M 10 -R 3 -r 3 big.txt

-M is for number of maps
-R is for number of reducers (keep it smaller than maps)
-r is for number of racks (allowed values 1, 2 or 3)

This will create the appropriate topology. There will also be a file
created called commands.txt which has all the commands that you can
run in one stroke. See below on how to run it.

However, I have purposely commented out the generation of the command
for the master in mr_mininet.py. That you will need to run manually so
that you can observe the output and also figure out if the process ran
to completion or not.

On the mininet prompt, do the following:

mininet> xterm h1s1

This will pop up an xterm window on host h1s1, which is where we are
going to run the master code.

Go to the Xterm window and type the following at the root prompt:

prompt # python mr_wordcount.py -p 5557 -m 10 -r 3 big.txt

Note that you MUST use the same port and number of map/reduce as what
you provided to the mininet topology generation. I know this is a
potential erroneous step which is why I had automated it but then we
cannot see the output. Hence, this small additional step. But be
careful.

You will notice some output on the xterm window.

Now go back to the window with your mininet prompt and type the
following: 

mininet> source commands.txt

and now observe what is going on in the Xterm window.  The process
should end.

In your directory, there should be a results.csv file which is the
final result. There will also be a number of *.out files, which are
the output of all the processes that started on each of the hosts.

Changes needed for your assignment
------------------------------------------------------

Clearly the big change you need is in the map and reduce worker
logic. However, it is my hypothesis that most of the overall framework
and workflow can remain untouched.

In the above source files, I have left a marker @NOTE@ in Python
comments in various places with a hint on what you might need to
change. 
